//starship config
const wallHardness = 0.2;
const friction = 1;
const offsetRaptors = [0, -1, 1];
const bottomOffset = 50;

//sky config
const NOISE_FACTOR = 0.05;
const NUMBER_OF_STARS = 100;
const MAX_STAR_SIZE = 5;    //in pixel

//global vars
let yOffset = 0;
let frictionFactor = 1;

//define a const Number property
const const_properties = {configurable: false, writable: false, enumerable: true};

//define the gravity
const Gravity = {
    G: 6.67408e-11,
    EARTH_RADIUS: 6371000,      //in meter
    EARTH_MASS: 5.9724e24,      //in Kg

    FORMULA: function(distance, Obj1Mass, Obj2Mass = this.EARTH_MASS){
        return this.G * ((Obj1Mass * Obj2Mass) / distance**2);
    }
}
ObjectSetAllProperties(Gravity, const_properties);

//define a raptor :
const Raptor = {
    THRUST_AT_SEA_LEVEL: 3050,  //in KiloNewton
    THRUST_IN_VACUUM: 3297,     //in KiloNewton
    MIN_THRUST: 20,             //in percentage
    O2_MASS_FLOW: 510,          //in Kg/s
    CH4_MASS_FLOW: 140          //in Kg/s
}
ObjectSetAllProperties(Gravity, const_properties);


//Starship object
class Starship{
    constructor(){
        //values of the starship :
        this.addConst("WIDTH", 9);
        this.addConst("HEIGHT", 50);
        this.addConst("EMPTY_MASS", 120000);

        //VARS:
        //mechanic values
        this.pos = new Vector2(canvas.width/2, canvas.height - bottomOffset);
        this.vel = new Vector2(0,0);
        this.acc = new Vector2(0,0);

        this.rotation = 0;
        this.rotationVel = 0;//in rad/sec
        this.rotationAcc = 0;//in rad/secÂ²

        //all the forces that interact with starship are in this object
        this.forces = {
            g: new Vector2(0,0),       //weight force
            f: new Vector2(0,0),       //friction force
            t: new Vector2(0,0),       //thrust force

            sum: () => {
                return this.forces.g.plusNew(this.forces.f.plusNew(this.forces.t));
            },

            updateFriction: (velocity, airDensity) => {
                this.forces.f.y = this.#FrictionApproximation(friction * frictionFactor, velocity.y, airDensity, this.#pseudoSurfaceInContactOfAir());
                this.forces.f.x = this.#FrictionApproximation(friction * frictionFactor, velocity.x, airDensity, this.#pseudoSurfaceInContactOfAir());
            },
            updateWeight: (mass, altitude) => {
                this.forces.g.y = Math.abs(Gravity.FORMULA(Gravity.EARTH_RADIUS + altitude, mass));
                this.forces.g.x = 0;
            },
            updateThrustForce: (angle, thrust) =>{
                this.forces.t.reset(0, -thrust);
                this.forces.t.rotate(angle, true);
            }
        }
        

        //mass in kg of the starship
        this.m = this.EMPTY_MASS;

        //thust force generated by the raptors in Newton
        this.thrust = 0;
        //angle of the raptors relatively to starship
        this.raptorsAngle = 0;

        //this indice is how much starship bounce on ground
        this.hardness = 1;

        //the image of the starship
        this.image = new Image();
        this.image.src = "starship.png";

        //the image of the raptor's flames
        this.flame = new Image();
        this.flame.src = "flame.png";
        this.flameHeights = [0,0,0];
        this.maxFlameHeight = this.HEIGHT * 0.8;
        
        //time system to use real time in the equations
        this.previousTime = 0;
        this.time = new Date().getTime();
        this.delta = 0;
    }
    update(){
        this.previousTime = this.time;
        this.time = new Date().getTime();
        this.delta = (this.time - this.previousTime) * 10e-3;

        //collision check
        let collision = false;

        const ySIze = mapInRange(Math.abs(Math.sin(this.rotation)), 0, 1, this.HEIGHT, this.WIDTH * 3.5);
        if(this.pos.y + ySIze >= canvas.height - bottomOffset){
            this.pos.y = canvas.height - bottomOffset - ySIze;
            this.vel.y = -Math.abs(this.vel.y * wallHardness * this.hardness);
            collision = true;
            //this.pos.y -= canvas.height - 50;
            if(Math.abs(this.vel.y) > 0.9){
                //console.log(this.vel.y); 
            }
        }
        if((this.pos.x + this.WIDTH) >= canvas.width){
            this.pos.x = canvas.width - this.WIDTH;
            this.vel.x = -Math.abs(this.vel.x * wallHardness * this.hardness);
            //collision = true;
        }
        if((this.pos.x) <= 0){
            this.pos.x = 0;
            this.vel.x = Math.abs(this.vel.x * wallHardness * this.hardness);
            //collision = true;
        }
        //collision consequence
        if(collision){
            frictionFactor = 10;
        }
        else{
            frictionFactor = 1;
        }

        //controls
        let raptorsOn = [false, false, false];
        if(keys.space){
            this.thrust = Raptor.THRUST_AT_SEA_LEVEL * 200 *  keys.numberOfRaptors;
            //turn on raptors
            for(let i = 0; i < keys.numberOfRaptors; i++){
                raptorsOn[i] = true;
            }
        }
        else{
            this.thrust = 0;
        }
        
        for(let i = 0; i < 3; i++){
            const h = this.flameHeights[i];
            if (raptorsOn[i]){
                this.flameHeights[i] = (h < this.maxFlameHeight) ? h + this.HEIGHT / 5 : this.maxFlameHeight;
            }
            else{
                this.flameHeights[i] = (h > 0) ? h - this.HEIGHT / 5 : 0;
            }
        }   

        if(keys.right){
            this.rotationVel = 0.3;
        }
        else{
            if(keys.left){
                this.rotationVel = -0.3;
            }
            else{this.rotationVel = 0;}
        }

        //update friction force
        this.forces.updateFriction(this.vel, Starship.getAirDensity(this.getAltitude()));
        //update gravity force
        this.forces.updateWeight(this.m, this.getAltitude());
        //update thrust force 
        this.forces.updateThrustForce(this.rotation + this.raptorsAngle, this.thrust);

        //update Rotation 
        this.rotationVel += this.rotationAcc * this.delta;
        this.rotation    += this.rotationVel * this.delta;
        //update acceleration with forces
        this.acc = this.forces.sum().divideNew(this.m);
        //update speed with acceleration and time between each frame
        this.vel.plusEq(this.acc.multiplyNew(this.delta));
        //update location with speed and time between each frame
        this.pos.plusEq(this.vel.multiplyNew(this.delta));
    }
    draw(x,y){
        for(let i = 0; i < 3; i++){
            ctx.beginPath();
            ctx.save();

            //this position is the bottom of the starship using his rotation
            let POS = new Vector2(0, this.HEIGHT / 2);
            POS.rotate(this.rotation, true);
            POS.plusEq(new Vector2(x + this.WIDTH / 2, y + this.HEIGHT / 2));
            ctx.translate(POS.x, POS.y);

            //set the rotation of the raptors
            const flameRotation = this.rotation + this.raptorsAngle + (Math.random() - 0.5)  * 0.02;
            ctx.rotate(flameRotation);

            //determine size and pos of the current flame 
            const flameWidth = this.WIDTH / 2 - Math.round(Math.random());
            const flamePos = new Vector2(-flameWidth / 4 * (offsetRaptors[i] + 1), -1).rotate(flameRotation, true);

            //draw the flame
            ctx.drawImage(this.flame, flamePos.x, flamePos.y, flameWidth, this.flameHeights[i]);
            ctx.restore();
            ctx.closePath();
        }
        ctx.save();

        ctx.translate(x + this.WIDTH / 2, y + this.HEIGHT / 2);
        ctx.rotate(this.rotation);

        ctx.drawImage(this.image, -this.WIDTH / 2, -this.HEIGHT / 2, this.WIDTH, this.HEIGHT);

        ctx.restore();
    }
    getSpeed(){
        return this.vel.magnitude();
    }
    getAltitude(){
        return canvas.height - this.pos.y - starship.HEIGHT - bottomOffset;
    }
    static getAirDensity(altitude){
        return Math.max(Math.min( 1 - (altitude / 110000 ), 1), 0);
    }
    addConst(name, value){
        Object.defineProperty(this, name, {
            value: value,
            writable: false,
            enumerable: true
        });
    }

    //privates methods

    //friction very simple approximation :
    #FrictionHugeApproximation(airConstant, velocity, nothing, nothing2){
        return -airConstant * velocity;
    }
    //friction best approximation that i find
    #FrictionApproximation(airConstant, velocity, airDensity, crossSectionalArea){
        return -0.5 * airConstant * airDensity * crossSectionalArea * velocity * Math.abs(velocity);
    }
    //pseudo because try to take in account to geometry of the starship
    #pseudoSurfaceInContactOfAir(){
        const bottomSurface = this.WIDTH * Math.PI;
        const sideSurface = this.WIDTH * this.HEIGHT * 0.6;//0.6 because of the round shape of the side 
        let ret = mapInRange(Math.abs(Math.sin(this.rotation)), 0, 1, bottomSurface, sideSurface);
        return ret;
    }
    //GRAVITY STUFF

}

//sky object
class Sky{
    constructor(){
        this.skyResolution = 50;
        this.pixelSize = 1;
        this.yOffset = 0;

        this.update();

        this.borderSize = 0;
        this.air = 1;
        this.alt = 0;
        this.starTexture = new Image();
        this.starTexture.src = "star.png";

        this.starsPos = new Array(0);
        for (let i = 0; i < NUMBER_OF_STARS; i++) {
            this.starsPos.push({x: Math.random(), y: Math.random(), size: Math.round(Math.random() * MAX_STAR_SIZE)});
        }

    }
    
    draw(){
        //sky background color
        canvas.style.backgroundColor = 'rgb(' + (this.air * 150) + ',' + (this.air * 250) + ',' + (this.air * 250) + ')';

        //stars
        ctx.beginPath();
        ctx.globalAlpha = 1 - this.air;

        this.starsPos.forEach(element => {
            ctx.drawImage(this.starTexture, canvas.width * element.x, canvas.height * element.y, element.size, element.size);
        });
        ctx.globalAlpha = 1;
        ctx.closePath();

        //clouds
        for (let w = 0; w < this.skyResolution; w++) {
            for (let h = -2; h < Math.ceil(canvas.height / this.pixelSize) + 1; h++) {

                const clouds = this.#sky(w * this.pixelSize, (h * this.pixelSize + (yOffset - (yOffset % this.pixelSize))));
                const screenAltitude = canvas.height - (h * this.pixelSize);
                const cloudsSize = (this.alt + screenAltitude < 3000) ? Math.min((this.alt / 2000), 1): this.air;
                
                //clouds color
                ctx.fillStyle = 'rgba(255,255,255,' + (cloudsSize - clouds) * this.air + ')';

                ctx.fillRect(
                    w * this.pixelSize - this.borderSize,
                    this.yOffset + h * this.pixelSize - this.borderSize,
                    this.pixelSize + this.borderSize * 2,
                    this.pixelSize + this.borderSize * 2
                );
            }
        }
    }
    update(){
        this.pixelSize = Math.ceil(canvas.width / this.skyResolution);
        this.yOffset = this.pixelSize - (yOffset % this.pixelSize);
        this.alt = canvas.height - yOffset - bottomOffset;
        this.air = Starship.getAirDensity(this.alt);
    }
    #sky(x, y){
        const fac = NOISE_FACTOR / this.skyResolution;
        return ((perlin.get(x * fac, y * fac) + 1) / 2) 
        + (perlin.get(x * fac * 2, y * fac * 2) * 0.5) 
        + (perlin.get(x * fac * 4, y * fac * 4) * 0.25);
    }
}